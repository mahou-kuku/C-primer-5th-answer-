## 练习4.1:
### 表达式5+10\*20/2的求值结果是多少?
答：  
* 105。
## 练习 4.2：
### 根据 4.12 节中的表，在下述表达式的合理位置添加括号，使得添加括号后运算对象的组合顺序与添加括号前一致。
```
*vec.begin()
*vec.begin() + 1
```
答：  
```
*(vec.begin());
(*(vec.begin())) + 1;
```
## 练习 4.3：
### C++语言没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了·余地。这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡,你认为这可以接受吗?请说出你的理由。
答：  
* 可以接受。程序员可以在保持代码清晰和可维护的同时，充分利用编译器的优化能力。理由如下：
* 优化编译器性能：通过不强制要求特定的求值顺序，编译器可以生成更高效的代码，提升程序执行速度。
* 提高可移植性：不同的编译器可能对优化有不同的实现策略。通过允许编译器自由选择求值顺序，可以提高程序在不同环境中的可移植性。
* 强迫程序员写出更清晰的代码：由于求值顺序的不确定性，程序员会被迫避免在同一表达式中对同一个对象进行多次修改。这样的代码更容易理解和维护。
## 练习 4.4：
### 在下面的表达式中添加括号，说明其求值的过程及最终结果。编写程序编译该（不加括号的）表达式并输出其结果验证之前的推断。
```
12 / 3 * 4 + 5 * 15 + 24 % 4 / 2
```
答：  
* (((12 / 3) * 4) +( 5 * 15)) + ((24 % 4) / 2) = ((4 * 4) + 75) + (0 / 2) = (16 + 75) + 0 = 91 + 0 = 91
```
#include <iostream>

int main() {
	std::cout << (((12 / 3) * 4) +( 5 * 15)) + ((24 % 4) / 2) << std::endl;
	std::cout << 12 / 3 * 4 + 5 * 15 + 24 % 4 / 2 <<std::endl;
	
	return 0;
}
```
## 练习 4.5:
### 写出下列表达式的求值结果。
```
(a)-30 * 3 + 21 / 5;
(b)-30 + 3 * 21 / 5;
(c)30 / 3 * 21 % 5;
(d)-30 / 3 * 21 % 4;
```
答：  
* (a)-86 (b)-18 (c)0 (d)-2
## 练习 4.6：
### 写出一条表达式用于确定一个整数是奇数还是偶数。
答：  
```
	if (number % 2 == 0) {
		//number 是偶数
	} else {
		//number 是奇数
	}
```
## 练习 4.7：
### 溢出是何含义？写出三条将导致溢出的表达式。
答：  
* 溢出是指当计算或赋值给一个变量的结果超出了该数据类型所能表示的范围时所发生的现象。溢出可能导致结果不正确或者不可预测。
* 以下是三条可能导致溢出的表达式：
```
//对于有符号整数溢出
int a = 2147483647;
int b = a + 1; // 当a是int类型的最大值时，加1会导致溢出，结果会变为最小的负数。

//对于无符号整数溢出：
unsigned int c = 0;
unsigned int d = c - 1; // 当c为0时，减1会导致无符号整数溢出，结果会变为无符号整数的最大值。

//对于浮点数溢出：
float e = 3.402823466e+38F;
float f = e * 2; // 当e是float类型的最大值时，乘以2会导致溢出，结果会变为无穷大（infinity）。
```
## 练习4.8:
### 说明在逻辑与、逻辑或及相等性运算符中运算对象求值的顺序。
答：  
* 逻辑与运算符（&&）：逻辑与运算符遵循“短路求值”或“从左到右求值”的原则。这意味着，如果运算符左侧的表达式的值为false，那么整个逻辑与表达式的结果就确定为false，右侧的表达式将不会被求值或执行。
* 逻辑或运算符（||）：逻辑或运算符也遵循“短路求值”或“从左到右求值”的原则。如果运算符左侧的表达式的值为true，那么整个逻辑或表达式的结果就确定为true，右侧的表达式将不会被求值或执行。
* 相等性运算符（== 和 !=）：对于相等性运算符，C++并没有规定运算对象的求值顺序。也就是说，如果两侧的表达式中有一个或者都有副作用（例如，修改了某个对象的值），那么这个表达式的行为就是未定义的。
## 练习 4.9:
### 解释在下面的if语句中条件部分的判断过程。
```
const char *cp = "Hello Whorld";
if (cp && *cp)
```
答：  
* 这个 if 语句常常用于确保一个字符串指针非空并且指向的字符串非空。
* 首先检查指针 cp 是否为非空,确保 cp 有效地指向了某个内存位置。由于 cp 指向了一个字符串字面量，所以这个条件为真。接下来检查 cp 所指向的字符是否非零，由于 cp 指向的字符是 'H'，所以这个条件也为真。因此，整个 if 条件为真，if 后面的语句将会被执行。
## 练习4.10:
### 为 while循环写一个条件，使其从标准输入中读取整数，遇到42 时停止。
答：  
```
int num = 0;
while (std::cin >> num && num != 42) {
	// 空循环体，只用于读取和检查数字
}
```
## 练习 4.11：
### 书写一条表达式用于测试4 个值 a、b、c、d 的关系，确保 a 大于 b、b大于c、c 大于d。
答：  
```
(a > b) && (b > c) && (c > d)
```
## 练习 4.12:
### 假设i、j和k是三个整数,说明表达式i!=j<k的含义。
答：  
* < 的优先级高于 != ，所以i != j < k 会被解析为 i != (j < k)。
* 这是一个逻辑上的混乱，因为这是在将一个整数 i 与一个布尔值进行比较。如果 i 不等于 0 或 1，那么无论 j < k 的结果如何，i != (j < k) 的结果都是 true。如果 i 等于 0 或 1，那么 i != (j < k) 的结果取决于 j < k 的结果是否与 i 相等。
## 练习 4.13：
### 在下述语句中，当赋值完成后i 和 d 的值分别是多少？
```
int i; double d;
(a) d = i = 3.5;	(b)i = d = 3.5;
```
答：  
* (a)3.0	(b)3
## 练习 4.14:
### 执行下述 if语句后将发生什么情况？
```
if (42 = i) // ...
if (i = 42) // ...
```
答：  
* 由于42不是一个左值，第一条语句尝试对其赋值将会导致编译错误。	  第二条语句是合法的，但可能不是你预期的。i将被赋值为42，由于42是一个非零值，所以它会被视为true，if后面的语句块会被执行。
## 练习4.15:
### 下面的赋值是非法的,为什么?应该如何修改?
```
double dval; int ival; int *pi;
dval = ival = pi = 0;
```
答：  
* 非法的原因在于pi是一个int指针，而不是一个int对象。不能将一个指针类型的值赋给一个int变量，修改如下
```
dval = ival = 0;
pi = nullptr;
```
## 练习 4.16：
### 尽管下面的语句合法，但它们实际执行的行为可能和预期并不一样，为什么？应该如何修改？
```
if (p = getPtr() != 0)
if (i = 1024)
```
答：  
* if (p = getPtr() != 0)的问题在于关系运算符!=的优先级高于赋值运算符=，所以getPtr() != 0会首先被计算，结果是一个布尔值。这个布尔值会赋值给p。如希望p获得getPtr()的返回值，然后再检查p是否非零，需要添加括号以改变运算的顺序。
* if (i = 1024) 中，i被赋值为1024，然后检查i是否非零。由于1024是非零的，所以这个if语句的条件总是为true。如果是想检查i是否等于1024，应该使用比较运算符==，而不是赋值运算符=。
* 修改如下：
```
if ((p = getPtr()) != 0)
if (i == 1024)
```
