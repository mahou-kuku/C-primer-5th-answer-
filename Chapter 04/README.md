## 练习4.1:
### 表达式5+10\*20/2的求值结果是多少?
答：  
* 105。
## 练习 4.2：
### 根据 4.12 节中的表，在下述表达式的合理位置添加括号，使得添加括号后运算对象的组合顺序与添加括号前一致。
```
*vec.begin()
*vec.begin() + 1
```
答：  
```
*(vec.begin());
(*(vec.begin())) + 1;
```
## 练习 4.3：
### C++语言没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了·余地。这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡,你认为这可以接受吗?请说出你的理由。
答：  
* 可以接受。程序员可以在保持代码清晰和可维护的同时，充分利用编译器的优化能力。理由如下：
* 优化编译器性能：通过不强制要求特定的求值顺序，编译器可以生成更高效的代码，提升程序执行速度。
* 提高可移植性：不同的编译器可能对优化有不同的实现策略。通过允许编译器自由选择求值顺序，可以提高程序在不同环境中的可移植性。
* 强迫程序员写出更清晰的代码：由于求值顺序的不确定性，程序员会被迫避免在同一表达式中对同一个对象进行多次修改。这样的代码更容易理解和维护。
## 练习 4.4：
### 在下面的表达式中添加括号，说明其求值的过程及最终结果。编写程序编译该（不加括号的）表达式并输出其结果验证之前的推断。
```
12 / 3 * 4 + 5 * 15 + 24 % 4 / 2
```
答：  
* (((12 / 3) * 4) +( 5 * 15)) + ((24 % 4) / 2) = ((4 * 4) + 75) + (0 / 2) = (16 + 75) + 0 = 91 + 0 = 91
```
#include <iostream>

int main() {
	std::cout << (((12 / 3) * 4) +( 5 * 15)) + ((24 % 4) / 2) << std::endl;
	std::cout << 12 / 3 * 4 + 5 * 15 + 24 % 4 / 2 <<std::endl;
	
	return 0;
}
```
## 练习 4.5:
### 写出下列表达式的求值结果。
```
(a)-30 * 3 + 21 / 5;
(b)-30 + 3 * 21 / 5;
(c)30 / 3 * 21 % 5;
(d)-30 / 3 * 21 % 4;
```
答：  
* (a)-86 (b)-18 (c)0 (d)-2
## 练习 4.6：
### 写出一条表达式用于确定一个整数是奇数还是偶数。
答：  
```
	if (number % 2 == 0) {
		//number 是偶数
	} else {
		//number 是奇数
	}
```
## 练习 4.7：
### 溢出是何含义？写出三条将导致溢出的表达式。
答：  
* 溢出是指当计算或赋值给一个变量的结果超出了该数据类型所能表示的范围时所发生的现象。溢出可能导致结果不正确或者不可预测。
* 以下是三条可能导致溢出的表达式：
```
//对于有符号整数溢出
int a = 2147483647;
int b = a + 1; // 当a是int类型的最大值时，加1会导致溢出，结果会变为最小的负数。

//对于无符号整数溢出：
unsigned int c = 0;
unsigned int d = c - 1; // 当c为0时，减1会导致无符号整数溢出，结果会变为无符号整数的最大值。

//对于浮点数溢出：
float e = 3.402823466e+38F;
float f = e * 2; // 当e是float类型的最大值时，乘以2会导致溢出，结果会变为无穷大（infinity）。
```
