## 练习2.1:  
### 类型 int、 long、 long long和short的区别是什么?无符号类型和带符号类型的区别是什么? float和double的区别是什么?  
答： 
* int、long、long long 和 short 的区别： 这些都是整数类型，区别在于它们所能表示的数值范围不同。C++ 标准规定了它们的最小尺寸，但实际尺寸可能因编译器和硬件而异。一般来说，short 至少为 16 位，int 至少为 16 位（通常为 32 位），long 至少为 32 位（通常为 32 或 64 位），而 long long 至少为 64 位。  
* 无符号类型和带符号类型的区别： 带符号类型可以表示正数、负数和零。无符号类型只能表示非负数（包括零）。这是因为无符号类型将所有可用位用于表示正数值，而带符号类型则保留一个位用于表示数值的正负。因此，在相同的位宽下，无符号类型能表示的正数范围比带符号类型大。  
* float 和 double 的区别： 这两种类型都是浮点数类型，用于表示实数。它们的区别在于所能表示的数值范围和精度。float 通常有 32 位，而 double 通常有 64 位。由于 double 类型具有更多的位宽，因此它能表示的数值范围更大，精度也更高。然而，尽管 double 的精度更高，但其计算代价却与 float 相差无几，在某些机器上，双精度运算甚至比单精度运算还快。因此，在实际应用中通常选择 double 类型。  
## 练习 2.2:  
### 计算按揭贷款时,对于利率、本金和付款分别应选择何种数据类型?说明你,的理由。  
答：  
* 都可以选择 double 类型。这三者通常都是一个小数，需要有一定的精度来表示。使用 double 类型可以提供足够的精度，同时计算代价与使用 float 类型相差无几。  
## 练习 2.3：  
### 读程序写结果。  
```
  unsigned u = 10, u2 = 42;
	std::cout << u2 - u << std::endl;
	std::cout << u - u2 << std::endl;

	int i = 10, i2 = 42;
	std::cout << i2 - i << std::endl;
	std::cout << i - i2 << std::endl;
	std::cout << i - u << std::endl;
	std::cout << u - i << std::endl;
```
答：  
* 结果如下：  
```
32
4294967264
32
-32
0
0
```
## 练习 2.4：  
### 编写程序检查你的估计是否正确，如果不正确，请仔细研读本节直到弄明白问题所在。  
答：  
* 预估正确。虽然对那两个0没什么信心，但经过测试确实没出什么幺蛾子。  
## 练习 2.5：  
### 指出下述字面值的数据类型并说明每一组内几种字面值的区别：  
```
(a) 'a', L'a', "a", L"a"
(b) 10, 10u, 10L, 10uL, 012, 0xC
(c) 3.14, 3.14f, 3.14L
(d) 10, 10u, 10., 10e-2
```
答：  
```
(a) 
'a': char 类型，表示一个字符；
L'a': wchar_t 类型，表示一个宽字符；
"a": 字符串字面值，实际上是一个以空字符 '\0' 结尾的 char 数组；
L"a": 宽字符串字面值，实际上是一个以空字符 L'\0' 结尾的 wchar_t 数组。
(b) 
10: int 类型，十进制整数；
10u: unsigned int 类型，十进制无符号整数；
10L: long 类型，十进制长整数；
10uL: unsigned long 类型，十进制无符号长整数；
012: int 类型，八进制整数；
0xC: int 类型，十六进制整数。
(c) 
3.14: double 类型，双精度浮点数；
3.14f: float 类型，单精度浮点数；
3.14L: long double 类型，长双精度浮点数。
(d) 
10: int 类型，十进制整数；
10u: unsigned int 类型，十进制无符号整数；
10.: double 类型，双精度浮点数，等同于 10.0；
10e-2: double 类型，双精度浮点数，等同于 10 * 10^(-2)。
```
## 练习 2.6：  
### 下面两组定义是否有区别,如果有,请叙述之  
```
int month = 9, day = 7;
int month= 09, day= 07;
```
答：  
*  有区别。第一行用来初始化的值都是十进制整数，第二行用来初始化的值都是八进制整数，而且09是一个无效的八进制数字，会产生编译错误。  
## 练习 2.7：  
### 下述字面值表示何种含义？它们各自的数据类型是什么？  
```
(a) "Who goes with F\145rgus?\012"
(b) 3.14e1L
(c) 1024f
(d) 3.14L
```
答：  
```
(a)输出 Who goes with Fergus? 并换行。	string 类型。
(b)输出 3.14 	long double 类型
(c)会产生编译错误。 后缀f只对浮点字面值有效。
(d)输出 3.14 	long double 类型
```
## 练习2.8:  
### 请利用转义序列编写一段程序,要求先输出2M,然后转到新一行。修改程序使其先输出 2，然后输出制表符，再输出 M，最后转到新一行。  
答：  
```
#include <iostream>
int main()
{
	std::cout << "\x32\x4D\xA";
	return 0;
}
```
* 修改后：  
```
#include <iostream>
int main()
{
	std::cout << "\x32\x9\x4D\xA";
	return 0;
}
```
## 练习 2.9：  
### 解释下列定义的含义。对于非法的定义，请说明错在何处并将其改正。  
```
(a) std::cin >> int input_value;
(b) int i = { 3.14 };
(c) double salary = wage = 9999.99; 
(d) int i = 3.14;
```
答： 
* (a) std::cin >> int input_value;  
* 这一行试图从标准输入读取一个整数并将其存储在名为 input_value 的变量中。但是，这里的定义是非法的，因为在 std::cin 读取之前应该先声明变量。修正如下：  
```
int input_value;
std::cin >> input_value;
```
* (b) int i = { 3.14 };  
* 这一行试图将浮点数 3.14 赋值给整数类型变量 i。这是不合法的，因为使用花括号进行列表初始化时，编译器不允许可能丢失信息的转换。改正如下：  
```
double i = { 3.14 };
```
* (c) double salary = wage = 9999.99;  
* 这一行试图将 9999.99 赋值给名为 salary 和 wage 的两个 double 类型变量。然而，这里的定义是非法的，因为在将值赋给 salary 和 wage 之前应该先声明 wage。修正如下：  
```
double wage = 9999.99;
double salary = wage;
```
* (d) int i = 3.14;
* 这一行将浮点数 3.14 赋值给整数类型变量 i。虽然这种赋值是合法的，但会导致精度损失，因为浮点数会被截断为整数。在这种情况下，i 的值将为 3。如果想保留小数部分，应该使用浮点数类型：  
```
double i = 3.14;
```
## 练习2.10:  
### 下列变量的初值分别是什么?  
```
std::string global_str;
int global_int;
int main()
{
    int local_int;
    std::string local_str;
}
```
答：  
* global_str 初始化为空字符串。  
* global_int 初始化为0。  
* local_int 并未初始化，值是未定义的。  
* local_str 默认初始化为空字符串。  
